package scodec

import scala.annotation.unchecked.uncheckedVariance

import scodec.bits.BitVector

/**
  * Supports encoding a value of type `A` to a `BitVector`.
  *
  * @groupname primary Primary Members
  * @groupprio primary 0
  *
  * @groupname combinators Basic Combinators
  * @groupprio combinators 10
  */
trait Encoder[-A] { self =>

  /**
    * Attempts to encode the specified value in to a bit vector.
    *
    * @param value value to encode
    * @return error or binary encoding of the value
    * @group primary
    */
  def encode(value: A): Attempt[BitVector]

  /**
    * Provides a bound on the size of successfully encoded values.
    *
    * @group primary
    */
  def sizeBound: SizeBound

  /**
    * Converts this encoder to an `Encoder[B]` using the supplied `B => A`.
    * @group combinators
    */
  def contramap[B](f: B => A): Encoder[B] = new Encoder[B] {
    def sizeBound = self.sizeBound
    def encode(b: B) = self.encode(f(b))
  }

  /**
    * Converts this encoder to an `Encoder[B]` using the supplied partial
    * function from `B` to `A`. The encoding will fail for any `B` that
    * `f` maps to `None`.
    * @group combinators
    */
  def pcontramap[B](f: B => Option[A]): Encoder[B] = new Encoder[B] {
    def sizeBound = self.sizeBound
    def encode(b: B): Attempt[BitVector] =
      f(b).map(self.encode).getOrElse(Attempt.failure(Err(s"widening failed: $b")))
  }

  /**
    * Converts this encoder to an `Encoder[B]` using the supplied `B => Attempt[A]`.
    * @group combinators
    */
  def econtramap[B](f: B => Attempt[A]): Encoder[B] = new Encoder[B] {
    def sizeBound = self.sizeBound
    def encode(b: B) = f(b).flatMap(self.encode)
  }

  /**
    * Converts this encoder to a new encoder that compacts the generated bit vector before returning it
    * @group combinators
    */
  def compact: Encoder[A] = new Encoder[A] {
    def sizeBound = self.sizeBound
    def encode(a: A) = self.encode(a).map(_.compact)
  }

  /**
    * Gets this as an `Encoder`.
    * @group combinators
    */
  def asEncoder: Encoder[A] = this

  /**
    * Converts this to a codec that fails decoding with an error.
    * @group combinators
    */
  def encodeOnly: Codec[A @uncheckedVariance] = new Codec[A] {
    def sizeBound = self.sizeBound
    def encode(a: A) = self.encode(a)
    def decode(bits: BitVector) = Attempt.failure(Err("decoding not supported"))
  }

  /**
    * Encodes all elements of the specified sequence and concatenates the results, or returns the first encountered error.
    * @group conv
    */
  def encodeAll(as: Iterable[A]): Attempt[BitVector] = {
    val buf = new collection.mutable.ArrayBuffer[BitVector](as.size)
    var failure: Err | Null = null
    as.foreach { a =>
      if (failure == null) {
        encode(a) match {
          case Attempt.Successful(aa) => buf += aa
          case Attempt.Failure(err)   => failure = err.pushContext(buf.size.toString)
        }
      }
    }
    if (failure == null) {
      def merge(offset: Int, size: Int): BitVector = size match {
        case 0 => BitVector.empty
        case 1 => buf(offset)
        case _ =>
          val half = size / 2
          merge(offset, half) ++ merge(offset + half, half + (if (size % 2 == 0) 0 else 1))
      }
      Attempt.successful(merge(0, buf.size))
    } else {
      Attempt.failure(failure.nn) // FIXME .nn shouldn't be necessary here b/c failure is checked for null above
    }
  }
}

/**
  * Provides functions for working with encoders.
  *
  * @groupname conv Conveniences
  * @groupprio conv 2
  *
  */
trait EncoderFunctions {

  /**
   * Encodes the specified value using the implicit `Encoder[A]`.
   * @group conv
   */
  final def encode[A](a: A)(using encA: Encoder[A]): Attempt[BitVector] =
    encA.encode(a)

  /**
    * Encodes the specified values, one after the other, to a bit vector using the specified encoders.
    * @group conv
    */
  final def encodeBoth[A, B](encA: Encoder[A], encB: Encoder[B])(a: A, b: B): Attempt[BitVector] =
    for {
      encodedA <- encA.encode(a)
      encodedB <- encB.encode(b)
    } yield encodedA ++ encodedB

  /**
    * Creates an encoder that encodes with each of the specified encoders, returning
    * the first successful result.
    * @group conv
    */
  final def choiceEncoder[A](encoders: Encoder[A]*): Encoder[A] = new Encoder[A] {
    def sizeBound = SizeBound.choice(encoders.map(_.sizeBound))
    def encode(a: A) = {
      @annotation.tailrec
      def go(rem: List[Encoder[A]], errs: List[Err]): Attempt[BitVector] = rem match {
        case Nil => Attempt.failure(Err(errs.reverse))
        case hd :: tl =>
          hd.encode(a) match {
            case res @ Attempt.Successful(_) => res
            case Attempt.Failure(err)        => go(tl, err :: errs)
          }
      }
      if (encoders.isEmpty) Attempt.failure(Err("no encoders provided"))
      else go(encoders.toList, Nil)
    }
  }
}

/**
  * Companion for [[Encoder]].
  *
  * @groupname ctor Constructors
  * @groupprio ctor 1
  *
  * @groupname inst Typeclass Instances
  * @groupprio inst 3
  */
object Encoder extends EncoderFunctions {

  inline def apply[A](using e: Encoder[A]): Encoder[A] = e

  /**
    * Creates an encoder from the specified function.
    * @group ctor
    */
  def apply[A](f: A => Attempt[BitVector]): Encoder[A] = new Encoder[A] {
    def sizeBound = SizeBound.unknown
    def encode(value: A) = f(value)
  }

  given Transform[Encoder] {
    def [A, B](fa: Encoder[A]).exmap(f: A => Attempt[B], g: B => Attempt[A]): Encoder[B] = 
      fa.econtramap(g)
  }

  implicit class AsSyntax[A](private val self: Encoder[A]) extends AnyVal {
    def as[B](using t: Transformer[A, B]): Encoder[B] = t(self)
  }
}
